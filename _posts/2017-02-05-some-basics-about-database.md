---
layout: post
title: 数据库系统的常识
date: 2017-02-05 15:47:59 +08:00
tags: 温故而知新
---

***

### 事务处理

* 事务来自于2个独立的需求: **并发数据库访问** 和 **系统错误恢复**.
* 一个事务可以被看作是 **一个单元的一系列SQL语句的集合**.

#### 事务特性 (A.C.I.D)

* A - 原子性 (Atomacity): 事务必须是原子工作单元,对于其数据修改,要么全都执行,要么全都不执行.
* C - 一致性 (Consistency): 事务将数据库从一种一致状态转变为下一种一致状态.
* I - 隔离性 (Isolation): 由并发事务所作的修改必须与任何其它并发事务所作的修改隔离.
* D - 持久性 (Durability): 事务完成之后,它对于系统的影响是永久性的.即使出现致命的系统故障也将一直保持.

#### 事务的隔离级别

* 不对数据库进行 **并发控制** ,会产生异常情况:
1. 脏读 (Dirty Read): 一个事务读取**另一个事务尚未提交的修改**产生脏读,同一事务内不是脏读. - 由于读取过程中,另一事务更新了数据没有及时提交造成的(数据可能被回滚).
2. 非重复读 (Nonrepeatable Read): 一个事务对**同一行数据重复读取两次**得到不同的结果. - 由于查询过程中,其他提交事务修改或删除数据造成的.
3. 幻像读 (Phantom Read): 事务在操作过程中进行**两次查询**,第二次查询结果包含第一次查询中未出现的数据(不要求两次查询的SQL语句相同). - 由于两次查询中,另一事务插入数据造成的.
4. 丢失修改 (Lost Update): a. 两个事物更新相同的数据源,第一个被提交,第二个被撤销,那么第一个做的更新也会被撤销. b. 两个并发事务同时读取同一行数据,第一个进行修改提交,第二个也进行修改提交,造成第一次写操作失效.

* 为了兼顾 **并发效率** 和 **异常控制**,标准SQL规范里定义了4个事务隔离级别:
1. 未提交读 (Read Uncommitted): 更新语句没有提交,别的事务可以读到改变数据. - 允许 **脏读**.
2. 已提交读 (Read Committed): 只能读取到已提交的数据. - 不允许 **脏读**, 允许 **非重复读**.(多数数据库默认该级别).
3. 可重复读 (Repeatable Read): 同一事务先后执行同一查询语句得到一样的结果. - 不允许 **脏读**,**非重复读**, 允许 **幻像读**.
4. 串行读 (Serializable): 串行化的读,当前事务执行时不允许别的事务并发进行.每次读需要获得 **表级共享锁**,读写都会阻塞. - 不允许 **不一致现象** 出现.

* 各隔离级别对各种异常的控制能力:

| | LU丢失修改 | DR脏读 | NRR非重复读 | SLU二类丢失修改 | PR幻像读 |
| --- | --- | --- | --- | --- | --- |
| RU 未提交读 | Y | Y | Y | Y | Y |
| RC 提交读 | N | N | Y | Y | Y |
| RR 可重复读 | N | N | N | N | Y |
| S 串行读 | N | N | N | N | N |
 
#### 事务隔离的实现 - 锁

* 共享锁(S锁): 用于只读操作(SELECT),锁定共享的资源. - 不阻止其他用户 **读**, 只阻止其他用户 **写**.
* 更新锁(U锁): 用于可更新的资源.防止多个会话读取,锁定,资源更新时发生死锁.
* 独立锁(X锁,排他锁): 一次只有一个独占锁用在一个资源上,阻止其他锁.写是独占锁,可有效的防止 **脏读**.

* Read Uncommited: 一个事务在**写数据**, 另外一事务则 **不允许** 同时进行 **写操作**, 但允许其他事务 **读数据**. 该隔离级别可以通过 **“排他写锁”** 实现.
* Read Committed **读取数据**的事务允许其他事务继续**访问该数据**; 但 **未提交的写事务** 会禁止 **其他事务访问该数据**. 可以通过 **“瞬间共享读锁”** 和 **“排他写锁”** 实现.
* Repeatable Read **读取数据**的事务 **禁止写事务**, 但 **允许读事务**, 写事务则**禁止任何其他事务**. 可以通过 **“共享读锁”** 和 **“排他写锁”** 实现.
* Serializable **读数据** 加 **共享锁**, **写数据** 加 **排他锁**, **读写互斥**.

* 一般处理并发问题时的步骤:
1. 开启事务.
2. 申请写权限,也就是给对象(表或记录)加锁.
3. 假如失败,则结束事务,过一会重试.
4. 假如成功,也就是给对象加锁成功,防止其他用户再用同样的方式打开.
5. 进行编辑操作.
6. 写入所进行的编辑结果.
7. 假如写入成功，则提交事务,完成操作.
8. 假如写入失败，则回滚事务，取消提交.
9. (7.8)两步操作已释放了锁定的对象,恢复到操作前的状态.

***

### 索引

* 数据库创建索引的优点: **提高系统的性能**
1. 创建唯一性的索引,保证数据库表中每一行数据的唯一性.
2. 加速数据的检索速度 -- **最主要的原因**.
3. 加速表与表之间的连接,特别在实现数据的参考完整性方面特别有意义.
4. 使用分组和排序子句进行数据检索时,可以显著的减少查询中分组和排序的时间.
5. 通过使用索引,可以在查询的过程中,使用优化隐藏器,提高系统的性能.

* 数据创建索引的缺点:
1. 创建索引和维护索引需要消耗时间,且随着数据增加而增加.
2. 索引需要占物理空间,除了数据表占据数据空间之外,每个索引还要占一定的物理空间.
3. 表的数据增加,删除,修改时,索引要动态维护,降低了数据维护的速度.

* 什么样的列建立索引:
1. 在主键的列上,强制该列的唯一性和组织表中数据的排列结构.
2. 在经常用在连接的列上,这些列主要是一些外键,可以加快连接的速度.
3. 在经常需要根据范围进行搜索的列上创建索引,因为索引已经排序,其指定的范围是连续的.
4. 在经常需要排序的列上创建索引,因为索引已经排序,这样查询可以利用索引的排序,加快排序查询时间.
5. 在经常使用在where子句中的列上面创建索引,加快条件的判断速度.

* 什么样的列不创建索引:
1. 在查询中很少使用或者作为参考的列不应该创建索引.
2. 对于那些只有很少数据值的列也不应该增加索引(比如性别,结果集的数据行占了表中数据行的很大比例,即需要在表中搜索的数据行的比例很大.增加索引,并不能明显加快检索速度).
3. 对于那些定义为text,image和bit数据类型的列不应该增加索引.因为这些列的数据量要么相当大,要么取值很少.
4. 当修改性能远远大于检索性能时,不应该创建索引,因为修改性能和检索性能是矛盾的.

* 创建索引的方法: 直接创建和间接创建.

* 索引特征:
1. 唯一性索引. -- 保证在索引列中的全部数据是唯一的,不包含冗余数据.
2. 复合索引. -- 一个索引创建在多列上,可以减少表中索引的数量.

***

此文参考于 [hit-alibaba.github.io][hit-alibaba.github.io],十分感谢.  
所有引用内容版权归原作者所有.  
使用 [知识共享“署名-非商业性使用-相同方式共享 3.0 中国大陆”许可协议][Lisence] 授权.

[hit-alibaba.github.io]: https://hit-alibaba.github.io/interview/
[Lisence]: https://creativecommons.org/licenses/by-nc-sa/3.0/cn/